---
title: "QA Missing Codes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{QA Missing Codes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mOMOP)
library(tidyverse)
```

This vignette takes a look at the Value Sets in the mCode Data Dictionary that are missing codes and how to handle them. We first get the data dictionary from the url found at http://hl7.org/implement/standards/fhir/us/mcode/index.html#Modeling and filter for the rows that are missing a Code value. 

```{r}
value_sets <- get_value_sets()
value_sets <-
  value_sets %>%
  filter(is.na(Code))
value_sets
```

There are 5 types of missing codes: 
1. SNOMED descendants of a specific SNOMED code  
2. 

```{r}
missing_codes_01 <-
value_sets %>%
  rubix::filter_at_grepl(col = `Logical Definition`,
                         grepl_phrase = "includes codes descending from") %>%
  select(ancestor_code = `Logical Definition`) %>%
  extract(col = ancestor_code,
          into = c("ancestor_code"),
          regex = "includes codes descending from ([0-9]{1,}) .*$",
          remove = TRUE)
missing_codes_01
```

```{r}
pg13::write_table(conn_fun = "pg13::local_connect()",
                 schema = "patelm9",
                 table_name = "mcode_snomed_ancestor_codes",
                 drop_existing = TRUE,
                 data = missing_codes_01)
```

```{r}
conn <- pg13::local_connect()
missing_codes_01b <-
pg13::query(conn = conn,
            sql_statement = 
              "
              WITH snomed AS (
                SELECT * 
                FROM omop_vocabulary.concept c 
                WHERE c.vocabulary_id = 'SNOMED'
              )
              SELECT m.*, c2.* 
              FROM patelm9.mcode_snomed_ancestor_codes m 
              INNER JOIN snomed s
              ON m.ancestor_code = s.concept_code 
              INNER JOIN omop_vocabulary.concept_ancestor ca 
              ON ca.ancestor_concept_id = s.concept_id 
              INNER JOIN snomed c2 
              ON c2.concept_id = ca.descendant_concept_id 
              ")
chariot::dcAthena(conn = conn)
```

```{r}
missing_codes_02 <-
value_sets %>%
  rubix::filter_at_grepl(col = `Logical Definition`,
                         grepl_phrase = "excludes codes descending from") %>%
  select(descendant_code = `Logical Definition`) %>%
  extract(col = descendant_code,
          into = c("descendant_code"),
          regex = "excludes codes descending from ([0-9]{1,}) .*$",
          remove = TRUE)
```

```{r}
pg13::write_table(conn_fun = "pg13::local_connect()",
                 schema = "patelm9",
                 tableName = "mcode_snomed_descendant_codes",
                 drop_existing = TRUE,
                 data = missing_codes_02)
```

```{r}
conn <- pg13::local_connect()
missing_codes_02b <-
pg13::query(conn = conn,
            sql_statement = 
              "
              WITH snomed AS (
                SELECT * 
                FROM omop_vocabulary.concept c 
                WHERE c.vocabulary_id = 'SNOMED'
              ),
              ancs AS (
                SELECT m.*, ca.ancestor_concept_id, ca.descendant_concept_id
                FROM patelm9.mcode_snomed_descendant_codes m 
                INNER JOIN snomed s
                ON m.descendant_code = s.concept_code 
                INNER JOIN omop_vocabulary.concept_ancestor ca 
                ON ca.descendant_concept_id = s.concept_id 
                INNER JOIN snomed c2 
                ON c2.concept_id = ca.ancestor_concept_id 
              )
              
              SELECT * 
              FROM ancs a 
              WHERE a.ancestor_concept_id NOT IN (
                  SELECT descendant_concept_id 
                  FROM ancs a2
              )
              ")
chariot::dcAthena(conn = conn)
```

